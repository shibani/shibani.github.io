---
layout: post
title:  "The JS Event Loop - Asynchronous"
date:   2018-06-20 15:23:55 -0500
categories: js
---
<style type="text/css">
  .code{
    font-family:"Courier New", Courier, monospace;
  }
</style>

Sequence of Events
1. We define the <span class="code">function display()</span>
2. We set a new variable <span class="code">const futureData</span>
1. fetch kicks of xmlhttprequest/xhr using the background feature - needs to know url and method (get or post).
2. stores a PROMISE OBJECT in memory.
    1. futureData is stored in memory with
        1. a value property which is empty at first, awaits xhr to return
        2. An onfulfilled property - this is an array of callback functions which will auto-trigger when the value updates
        3. An onrejected property
3. futureData stores this PROMISE object which acts like a placeholder
4. The then function sends a function definition. futureData.onfulfilled.push(display) is what’s happening under the hood but JS does not allow you to do this directly.
5. The CALLSTACK gets each callback pushed onto the itself with value in promise as the data arg.
    1. ‘Fetch’ triggers the xhr request and creates the promise object
    2. ‘Then’ stores the callbacks in the promise object.
6. JS has a MICROTASK or JOB QUEUE which gets executed before the CALLBACK QUEUE.  JS gives precedence to the MICROTASK queue


![Asynchronous JS Event Loop]({{ "assets/images/js-event-loop-async.png"| absolute_url }})
